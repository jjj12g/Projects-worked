// Fill out your copyright notice in the Description page of Project Settings.


#include "Tile/GridManager.h"
#include "Tile/Tile.h"
#include "Math/UnrealMathUtility.h"
#include "Kismet/GameplayStatics.h"
#include "Enemy/EnemySpawner.h"



// Sets default values
AGridManager::AGridManager()
{
 	// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.
	PrimaryActorTick.bCanEverTick = true;


    // 기본값 설정 (에디터에서 변경 가능)
    GridShape = EGridShape::Hexagonal;
    NumCols = 10;
    NumRows = 10;
    HexSize = 100.f;
    HexRadius = 3;

}


// Called when the game starts or when spawned
void AGridManager::BeginPlay()
{
	Super::BeginPlay();
	
    bool bIsGridGenerated = false;
    if (!bIsGridGenerated)
    {
        GenerateGrid();
        bIsGridGenerated = true;
        //UE_LOG(LogTemp, Warning, TEXT("GenerateHexGrid called by: %s"), *GetName());
    }
    else
    {
        //UE_LOG(LogTemp, Warning, TEXT("Grid already generated by: %s"), *GetName());
    }

    // 에너미 스포너 찾기
    EnemySpawner = Cast<AEnemySpawner>(UGameplayStatics::GetActorOfClass(GetWorld(), AEnemySpawner::StaticClass()));

    if (EnemySpawner)
    {
        //UE_LOG(LogTemp, Warning, TEXT("EnemySpawner found: %s"), *EnemySpawner->GetName());

        // GridManager 초기화 이후 에너미 스폰
        EnemySpawner->GridManager = this; // GridManager를 설정
        EnemySpawner->SpawnEnemies();
    }
    else
    {
        //UE_LOG(LogTemp, Warning, TEXT("EnemySpawner not found in the level!"));
    }

    //UE_LOG(LogTemp, Warning, TEXT("2"));

}

// Called every frame
void AGridManager::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

}


void AGridManager::GenerateGrid()
{
    // 기존 그리드 정보를 초기화
    TileMap.Empty();
    AllTiles.Empty();

    // GridShape에 따라 다른 생성 함수 호출
    if (GridShape == EGridShape::Hexagonal)
    {
        GenerateHexGrid();
    }
    else if (GridShape == EGridShape::Rectangular)
    {
        GenerateHexShapedGrid();
    }
}

// 육각형 타일 그리드를 생성
void AGridManager::GenerateHexGrid()
{
    bShapedGrid = true;
    if (!TileClass)
    {
        //UE_LOG(LogTemp, Warning, TEXT("TileClass is not set! Cannot generate grid."));
        return;
    }

    for (int32 Q = 0; Q < NumCols; ++Q)
    {
        for (int32 R = 0; R < NumRows; ++R)
        {
            FIntPoint TileKey(Q, R);

            if (TileMap.Contains(TileKey))
            {
                //UE_LOG(LogTemp, Warning, TEXT("Duplicate tile generation attempt at Q=%d, R=%d"), Q, R);
                continue;
            }

            FVector TilePos = GetTilePosition(Q, R);
            ATile* SpawnedTile = GetWorld()->SpawnActor<ATile>(TileClass, TilePos, FRotator::ZeroRotator);

            if (SpawnedTile)
            {
                bool bWalkable = true; // 기본적으로 모든 타일을 Walkable로 설정
                SpawnedTile->InitializeTile(Q, R, bWalkable);
                TileMap.Add(TileKey, SpawnedTile);
                AllTiles.Add(SpawnedTile); // AllTiles에 추가
                //UE_LOG(LogTemp, Log, TEXT("Tile created at Q=%d, R=%d"), Q, R);
            }
        }
    }
}

void AGridManager::GenerateHexShapedGrid()
{
    bShapedGrid = false;
    if (!TileClass)
    {
        UE_LOG(LogTemp, Warning, TEXT("TileClass is not set! Cannot generate hex-shaped map."));
        return;
    }

    // 기존 타일 초기화
    TileMap.Empty();
    AllTiles.Empty();

    // -HexRadius ~ +HexRadius 범위 순회 (Cube→Axial 변환)
    for (int x = -HexRadius; x <= HexRadius; x++)
    {
        for (int y = -HexRadius; y <= HexRadius; y++)
        {
            int z = -x - y;
            // z가 범위를 벗어나면 육각형 밖
            if (FMath::Abs(z) > HexRadius)
            {
                continue;
            }

            // Axial 좌표 (q, r) = (x, z)
            int q = x;
            int r = z;

            // 중복 체크
            FIntPoint Key(q, r);
            if (TileMap.Contains(Key))
            {
                continue;
            }

            // 위치 계산
            FVector WorldPos = GetTilePosition(q, r);
            // 타일 스폰
            ATile* SpawnedTile = GetWorld()->SpawnActor<ATile>(TileClass, WorldPos, FRotator::ZeroRotator);
            if (SpawnedTile)
            {
                // bWalkable은 임의
                bool bWalkable = true;
                SpawnedTile->InitializeTile(q, r, bWalkable);

                TileMap.Add(Key, SpawnedTile);
                AllTiles.Add(SpawnedTile);

                // 디버그 출력
                //UE_LOG(LogTemp, Log, TEXT("Spawned tile at q=%d, r=%d -> X=%.1f, Y=%.1f"), q, r, WorldPos.X, WorldPos.Y);
            }
        }
    }
}



// 타일의 위치를 계산하는 함수
FVector AGridManager::GetTilePosition(int32 Q, int32 R) const
{
    if (bShapedGrid)
    {
         float HexWidth = 2 * HexSize;           // 육각형의 가로 길이
         float HexHeight = FMath::Sqrt(3.0f) * HexSize; // 육각형의 세로 길이

         // 홀수 Q 열의 R 좌표에 대한 오프셋 추가
         float OffsetY = (Q % 2 != 0) ? HexHeight / 2 : 0;

         float X = Q * HexWidth * 0.75f; // 가로 방향으로 75% 간격으로 배치
         float Y = R * HexHeight + OffsetY; // 세로 방향 오프셋 추가


         // 원하는 만큼 원점(0,0)을 중앙에 맞추기 위해 추가 보정
         //예: (HexRadius * 0.75f * HexWidth)만큼 왼쪽/위로 이동
         float CenterOffsetX = -(0.75f * HexWidth * HexRadius);
         float CenterOffsetY = -(HexHeight * HexRadius);

         return FVector(X, Y, 0);
    }
    else if (!bShapedGrid)
    {
        float x = FMath::Sqrt(3.f) * HexSize * (Q + (R * 0.5f));
        float y = (1.5f * HexSize) * R;

        // 맵 전체를 중앙(0,0)에 맞추기 위한 오프셋 (HexRadius를 기준으로 함)
        float offsetX = -FMath::Sqrt(3.f) * HexSize * HexRadius;
        float offsetY = -(1.5f * HexSize * HexRadius);

        FVector pos = FVector(x + offsetX, y + offsetY, 0.f);

        // 90도 회전 (시계방향): (x, y) -> (y, -x)
        float rotatedX = pos.Y;
        float rotatedY = -pos.X;
        return FVector(rotatedX, rotatedY, 0.f);
    }
   
    return FVector(Q, R, 0);
}


ATile* AGridManager::GetTileAt(int32 Q, int32 R) const
{
    FIntPoint Key(Q, R);
    if (TileMap.Contains(Key))
    {
        return TileMap[Key];
    }
    return nullptr;
}

bool AGridManager::IsTileWalkable(int32 Q, int32 R) const
{
    // 타일을 가져옴
    ATile* Tile = GetTileAt(Q, R);
    // 타일이 존재하고 이동 가능 여부를 반환
    return Tile && Tile->IsWalkable();
}

FIntPoint AGridManager::GetTileCoordinatesFromPosition(const FVector& Position) const
{
    float HexWidth = 2 * HexSize;
    float HexHeight = FMath::Sqrt(3.0f) * HexSize;

    float Q = Position.X / (HexWidth * 0.75f);
    float R = (Position.Y - ((int32)Q % 2 == 0 ? 0 : HexHeight / 2)) / HexHeight;

    int32 RoundedQ = FMath::RoundToInt(Q);
    int32 RoundedR = FMath::RoundToInt(R);

    return FIntPoint(RoundedQ, RoundedR);
}




bool AGridManager::IsTileOccupied(int32 Q, int32 R) const
{
    ATile* Tile = GetTileAt(Q, R);
    return Tile && Tile->OccupyingEnemy != nullptr;
}

ATile* AGridManager::GetTileAtLocation(const FVector& Location) const
{
    for (ATile* Tile : AllTiles) // AllTiles는 GridManager가 관리하는 모든 타일 배열
    {
        if (Tile && FVector::Dist2D(Tile->GetActorLocation(), Location) < Tolerance)
        {
            return Tile;
        }
    }
    return nullptr;
    //// 월드 좌표를 기반으로 Q, R 좌표 계산
    //FIntPoint TileCoords = GetTileCoordinatesFromPosition(Location);

    //// 계산된 Q, R 좌표를 사용하여 타일 반환
    //return GetTileAt(TileCoords.X, TileCoords.Y);
}

void AGridManager::HighlightValidTiles(const TArray<FIntPoint>& ValidTiles)
{
    for (const FIntPoint& TileKey : ValidTiles)
    {
        if (ATile* Tile = GetTileAt(TileKey.X, TileKey.Y))
        {
            Tile->Highlight(true);
        }
    }
}

void AGridManager::ClearHighlightedTiles()
{
    for (auto& TilePair : TileMap)
    {
        TilePair.Value->Highlight(false);
    }
}

TArray<ATile*> AGridManager::FindPath(ATile* StartTile, ATile* TargetTile)
{
    TArray<ATile*> OpenSet;    // 탐색해야 할 타일들
    TSet<ATile*> ClosedSet;    // 이미 탐색한 타일들

    OpenSet.Add(StartTile);

    // 초기화
    StartTile->GCost = 0;
    StartTile->HCost = GetDistance(StartTile, TargetTile);
    StartTile->FCost = StartTile->GCost + StartTile->HCost;
    StartTile->ParentTile = nullptr;

    while (OpenSet.Num() > 0)
    {
        // OpenSet에서 FCost가 가장 낮은 타일 찾기
        ATile* CurrentTile = OpenSet[0];
        for (ATile* Tile : OpenSet)
        {
            if (Tile->FCost < CurrentTile->FCost ||
                (Tile->FCost == CurrentTile->FCost && Tile->HCost < CurrentTile->HCost))
            {
                CurrentTile = Tile;
            }
        }

        // 목표 타일에 도달한 경우
        if (CurrentTile == TargetTile)
        {
            return RetracePath(StartTile, TargetTile);
        }

        OpenSet.Remove(CurrentTile);
        ClosedSet.Add(CurrentTile);

        // 이웃 타일 탐색
        for (ATile* Neighbor : GetNeighboringTiles(CurrentTile))
        {
            if (ClosedSet.Contains(Neighbor) || !Neighbor->bIsWalkable)
            {
                continue;
            }

            float NewGCost = CurrentTile->GCost + GetDistance(CurrentTile, Neighbor);
            if (NewGCost < Neighbor->GCost || !OpenSet.Contains(Neighbor))
            {
                Neighbor->GCost = NewGCost;
                Neighbor->HCost = GetDistance(Neighbor, TargetTile);
                Neighbor->FCost = Neighbor->GCost + Neighbor->HCost;
                Neighbor->ParentTile = CurrentTile;

                if (!OpenSet.Contains(Neighbor))
                {
                    OpenSet.Add(Neighbor);
                }
            }
        }
    }

    // 경로를 찾지 못한 경우
    return TArray<ATile*>();
}

// 경로를 역추적
TArray<ATile*> AGridManager::RetracePath(ATile* StartTile, ATile* EndTile)
{
    TArray<ATile*> Path;
    ATile* CurrentTile = EndTile;

    while (CurrentTile != StartTile)
    {
        Path.Add(CurrentTile);
        CurrentTile = CurrentTile->ParentTile;
    }

    Algo::Reverse(Path); // 역순으로 추가했으므로 뒤집기
    return Path;
}

// 두 타일 간 거리 계산
float AGridManager::GetDistance(ATile* TileA, ATile* TileB)
{
    int32 DeltaQ = FMath::Abs(TileA->Q - TileB->Q);
    int32 DeltaR = FMath::Abs(TileA->R - TileB->R);

    return DeltaQ + DeltaR; // 육각형 거리
}


// 인근타일 검색
TArray<ATile*> AGridManager::GetNeighboringTiles(ATile* CurrentTile)
{
    TArray<ATile*> Neighbors;
    if (!CurrentTile) return Neighbors;

    if (bShapedGrid)
    {
        TArray<FIntPoint> Offsets = (CurrentTile->Q % 2 == 0)
            ? TArray<FIntPoint>{{0, -1}, { 0, 1 }, { 1, 0 }, { 1, -1 }, { -1, 0 }, { -1, -1 }}
        : TArray<FIntPoint>{ {0, -1}, {0, 1}, {1, 0}, {1, 1}, {-1, 0}, {-1, 1} };

        for (const FIntPoint& Offset : Offsets)
        {
            ATile* Neighbor = GetTileAt(CurrentTile->Q + Offset.X, CurrentTile->R + Offset.Y);
            if (Neighbor)
            {
                Neighbors.Add(Neighbor);
            }
        }

        return Neighbors;
    }
    else if (!bShapedGrid)
    {

        // Pointy-Top Axial에서의 이웃 오프셋
        // (q+1,r), (q-1,r), (q,r+1), (q,r-1), (q+1,r-1), (q-1,r+1)
        static TArray<FIntPoint> AxialOffsets = {
            {+1,  0},
            {-1,  0},
            { 0, +1},
            { 0, -1},
            {+1, -1},
            {-1, +1}
        };

        int q = CurrentTile->Q;
        int r = CurrentTile->R;

        for (auto& Offset : AxialOffsets)
        {
            int nq = q + Offset.X;
            int nr = r + Offset.Y;
            ATile* NeighborTile = GetTileAt(nq, nr);
            if (NeighborTile)
            {
                Neighbors.Add(NeighborTile);
            }
        }
        return Neighbors;
    }

    return Neighbors;
}
